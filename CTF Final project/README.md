
# 網路攻防期末專題




## 題目說明

`Math is cool! Use the RSA algorithm to decode the secret message, c, p, q, and e are parameters for the RSA algorithm.`

`p =  964842302901051567659055174001042653494573763923573980064398935203985250729849139956
1035009163427050370107570733633350911691280297777160200625281665378483`

`q =  118748438379802970320924058486536568527609101545433809076500401907042833589092085782
51063047732443992230647903887510065547947313543299303261986053486569407`

`e =  65537`

`c =  832082989951746041747735902982036393605400248712561268928896613457424033149298619391
00492666605647316646576486526217457006376842280869728581726746401583705899941768214138742
25968933484073563355305388764184765117377625182029308721288567018036740680740676592363897
3161375817392737747832762751690104423869019034`

`Use RSA to find the secret message`


&emsp;&emsp;這是一個有關於RSA加密演算法的題目，RSA是一種非對稱式加密法，對極大整數做因數分解的難度決定了RSA演算法的可靠性，
到目前為止，世界上還沒有任何可靠的攻擊RSA演算法的方式。只要其鑰匙的長度足夠長，用RSA加密的訊息實際上是不能被破解的。

&emsp;&emsp;一般RSA的破解，只會得到N E C三個元素，但這個來自[實驗吧](http://www.shiyanbar.com/ctf/practice "link") 
的題目提供的則是已經將N分解為PQ，因此在做完這題目後，我更深入探討，若在沒有得到PQ的前提下，該如何分解大數N來得到secret message?

## CTF題目(原RSA題目延伸)

#### 在只得到n、e以及透過RSA加密所得到的密文c的情況下，如何有效率的分解N以得到訊息?

&emsp;&emsp;其實網上有許多幫助運算質因數分解的資源，背後很多就是依靠著Pollard′s rho algorithm。
從[1, N]中隨機取一個數，取得 P或Q 的概率為 2/N-1，因此若是要求出P
，我們必須不停的使用不同的隨機數來重複找尋其中一個因數，但是我們可以透過”生日悖論”來提高中獎的機率。
試想，如果一個房間里有30個人，那麼至少有兩個人的生日相同的概率是多少? 
![image](https://github.com/tim86101/CS335-CTF/blob/main/CTF%20Final%20project/formula.png)
&emsp;&emsp;透過這種不重複選取的方式，我們就能大大的提升找到因數的機率。回到原本題目，[2,N-1]只有2個數能整除𝑁(𝑝 , 𝑞)
，但如果我們問說有多少個數使𝑔𝑐𝑑(𝑥, 𝑁) > 1，答案就有很多了，共有𝑝 + 𝑞 − 2 個數。
![image](https://github.com/tim86101/CS335-CTF/blob/main/CTF%20Final%20project/formula2.png)
&emsp;&emsp;因此，我們只要透過一個能夠隨機產生一個不重複的數，相較之下我們就能夠比較快地找到這個與N不互質的數，進而找到P。

## 實驗結果
![image](https://github.com/tim86101/CS335-CTF/blob/main/CTF%20Final%20project/result.png)
i為分解嘗試的次數，也就是說透過Pollard′s rho algorithm 只用了528次，即破解了2^30大的數字的RSA加密系統。
  
